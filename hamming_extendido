def decodificar_y_corregir_hamming_full(palabra_recibida: str):
    """
    Verifica una palabra de código de 12 bits, corrige un error de un solo bit,
    extrae los 8 bits de datos originales y devuelve:
      (datos_corregidos_str, palabra_corregida_12bits_str, posicion_error)
    Igual que tu función, pero devuelve la palabra corregida completa para poder comparar.
    """
    if len(palabra_recibida) != 12:
        raise ValueError("Se requieren 12 bits de palabra de código.")

    # Convertir a lista de enteros e añadir 0 inicial (índice 1-12)
    palabra = [0] + [int(b) for b in palabra_recibida]

    # Calculando los bits de chequeo para formar el sindrome
    c1 = xor_list([palabra[i] for i in [1, 3, 5, 7, 9, 11]])
    c2 = xor_list([palabra[i] for i in [2, 3, 6, 7, 10, 11]])
    c4 = xor_list([palabra[i] for i in [4, 5, 6, 7, 12]])
    c8 = xor_list([palabra[i] for i in [8, 9, 10, 11, 12]])

    # nota: formamos el síndrome en orden c8 c4 c2 c1 para obtener la posición en binario MSB->LSB
    sindrome_binario = str(c8) + str(c4) + str(c2) + str(c1)
    posicion_error = int(sindrome_binario, 2)

    # Corrigiendo error existente (si hay)
    if posicion_error != 0:
        # invertir el bit erroneo
        palabra[posicion_error] = 1 - palabra[posicion_error]
        # palabra ahora contiene el código corregido (en índices 1..12)
    # sino, palabra ya es la original

    # recopilando el mensaje original, de D1 a D8 (posiciones fijas)
    posiciones_datos = [3, 5, 6, 7, 9, 10, 11, 12]
    datos_corregidos = "".join(str(palabra[i]) for i in posiciones_datos)

    # construir palabra corregida como string de 12 bits (índices 1..12)
    palabra_corregida = "".join(str(palabra[i]) for i in range(1, 13))

    return datos_corregidos, palabra_corregida, posicion_error


def comparar_palabras(original: str, corregida: str):
    """
    Compara dos palabras de 12 bits (original vs corregida) y devuelve una lista con
    las diferencias encontradas. Cada elemento de la lista es un diccionario:
      {
        'pos_global': int,        # posición 1..12
        'bit_original': '0'/'1',
        'bit_corregido': '0'/'1',
        'tipo': 'paridad'|'dato',
        'dato_indice': None|1..8  # si es un bit de dato, indica cual (D1..D8)
      }
    Si las longitudes difieren, se hace padding con '0' a la más corta (aunque para Hamming(12,8)
    ambas deberían tener 12 bits).
    """
    # Asegurar longitud
    maxlen = max(len(original), len(corregida))
    orig = original.ljust(maxlen, '0')
    corr = corregida.ljust(maxlen, '0')

    # definición de posiciones de paridad y de datos (para Hamming 12,8)
    posiciones_paridad = {1, 2, 4, 8}
    posiciones_datos = [3, 5, 6, 7, 9, 10, 11, 12]  # mapeo a D1..D8 (en ese orden)

    diffs = []
    for i in range(maxlen):
        bo = orig[i]
        bc = corr[i]
        if bo != bc:
            pos = i + 1  # 1-index
            if pos in posiciones_paridad:
                tipo = 'paridad'
                dato_idx = None
            else:
                tipo = 'dato'
                # obtener índice del dato (1..8) si aplica
                try:
                    dato_idx = posiciones_datos.index(pos) + 1
                except ValueError:
                    dato_idx = None
            diffs.append({
                'pos_global': pos,
                'bit_original': bo,
                'bit_corregido': bc,
                'tipo': tipo,
                'dato_indice': dato_idx
            })
    return diffs


# -------------------------
# Ejemplo de uso
# -------------------------
if __name__ == "__main__":
    # palabra_original_12bits es la que recibiste (por ejemplo con un error introducido)
    palabra_original_12bits = "110100110011"  # ejemplo: reemplaza por la tuya

    # Usamos la función que corrige y devuelve la palabra corregida completa
    datos, palabra_corregida, posicion = decodificar_y_corregir_hamming_full(palabra_original_12bits)

    print("Palabra original : ", palabra_original_12bits)
    print("Palabra corregida: ", palabra_corregida)
    print("Datos recuperados : ", datos)
    if posicion != 0:
        print(f"Se corrigió la posición {posicion} (1-index).")
    else:
        print("No se detectó ningún error de un solo bit.")

    # Comparar y mostrar todas las diferencias entre original y corregida
    diferencias = comparar_palabras(palabra_original_12bits, palabra_corregida)
    if diferencias:
        print("\nDiferencias encontradas (pos_global, tipo, dato_idx, orig->corr):")
        for d in diferencias:
            print(f" - Pos {d['pos_global']:2d}: {d['tipo']:7s} "
                  f"{('D'+str(d['dato_indice'])) if d['dato_indice'] else '':6s}"
                  f" {d['bit_original']} -> {d['bit_corregido']}")
    else:
        print("\nNo hay diferencias entre la palabra original y la corregida.")
