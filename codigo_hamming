def xor_list(bit_list):
    #comenzamos con el XOR PARA LA LISTA QUE ME DEN de hamming (12,8)
    resultado = 0
    for bit in bit_list:
        resultado ^= bit
    return resultado
def decodificar_y_corregir_hamming(palabra_recibida: str) -> str:
    """
    Verifica una palabra de código de 12 bits, corrige un error de un solo bit, 
    y extrae los 8 bits de datos originales.
    """
    if len(palabra_recibida) != 12:
        raise ValueError("Se requieren 12 bits de palabra de código.")

    # Convertir a lista de enteros e añadir 0 inicial (índice 1-12)
    palabra = [0] + [int(b) for b in palabra_recibida] 

    # Calculando los bits de chequeo para formar en sindrome :)
    

    c1 = xor_list([palabra[i] for i in [1, 3, 5, 7, 9, 11]])

  
    c2 = xor_list([palabra[i] for i in [2, 3, 6, 7, 10, 11]])


    c4 = xor_list([palabra[i] for i in [4, 5, 6, 7, 12]])

    
    c8 = xor_list([palabra[i] for i in [8, 9, 10, 11, 12]])


    sindrome_binario = str(c8) + str(c4) + str(c2) + str(c1)
    posicion_error = int(sindrome_binario, 2)

    #  Corrigiendo error existente
    if posicion_error != 0:
        print(f"  [ERROR DETECTADO]: El Síndrome {sindrome_binario} indica error en la Posición {posicion_error}.")
        # Invirtiendo el bit erroneo si hay
        palabra[posicion_error] = 1 - palabra[posicion_error]
        print(f"  [CORRECCIÓN]: Bit en Posición {posicion_error} invertido.")
    else:
        print("  [ESTADO]: No se detectaron errores de un solo bit.")

    # recopilando el mensaje original, de D1 a D8
    posiciones_datos = [3, 5, 6, 7, 9, 10, 11, 12]
    datos_corregidos = "".join(map(str, [palabra[i] for i in posiciones_datos]))
    
    return datos_corregidos